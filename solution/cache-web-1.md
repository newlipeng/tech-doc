# WEB系统通用缓存方案（上）

在WEB项目中通常需要解决性能问题，缓存是解决性能的一种比较通用的方案。

本文提供比较全面的缓存方案供大家参考

## 术语
   * 缓存时间：
       * 缓存的过期时间
   * 多级缓存：
       * 缓存分为集群缓存（二级缓存）和单机缓存（一级缓存）；
       * 一级缓存更接近应用，性能更高，缓存时间更短，命中率更低
       * 二级缓存更接近数据提供方，性能较低，缓存时间有差别（业务和性能兼顾），命中率更高
   * 被动缓存：
       * 请求服务时，通过被动请求获取数据，将数据放置到缓存服务中
   * 主动缓存：
       * 已知请求时会应用到的缓存内容，通过主动计算的方式提前将数据放置到缓存服务中（由服务提提供方放置）

## 数据来源性能和可用性是导致缓存服务的引入原因

   * 数据提供方通常是两种
        1. 数据库服务
        2. 接口服务
   * 当这些服务的性能和可用性无法满足业务需求时，会考虑引入缓存服务，达成业务需求

## 缓存服务选型

   * 缓存服务选型（memcache，redis）是两种比较通用的缓存服务。通常选择redis作为第一缓存服务选择，mecache作为第二缓存服务。这两种缓存服务同时可以提供单机和分布式多种，redis支持hash和cluster两种分布式方式。

   * 单机和语言相关的缓存，java采用ehcache，Spring Boot cache；php高版本采用apcu；go采用自维护的cache类库，map。

## 缓存场景、问题和解决方案

### 场景A：（多资源缓存，被动缓存）
   * key为，固定前缀(有意义的字符串<font color=#F07832>[a-zA-Z_-]</font>)+ID(<font color=#F07832>[0-9]</font>)，
   * value为，任意的字符串。
   * 例：
   ```
       user_54321存储用户ID为54321的信息
       product_54321存储产品ID为54321的信息
       注意：虽然memcache，redis均支持只有数字的key，不要用避免混淆。
   ```

### 可能带来的问题及解决方案
###### 1，大量KEY在同一时间全部失效；
   * 由于采用被动缓存，同时触发的并同时失效的可能性低，并且任何引入避免同时失效的方案均带来其他问题。
###### 解决方案A-1-1：
   * 不解决

###### 2，大量KEY的有效数据是空值，没有被缓存；
###### 解决方案A-2-1：
   * 缓存空值，即使是空置也进行缓存；根据空置key的分布和业务特点衡量缓存的过期时间是否增加随机值，打散缓存同时失效的可能行。
###### 方案特点：
   * 缓存过期时间相对较短，主要用于解决性能问题
   * 如果业务特点导致多KEY同时生成，则采用随机过期时间解决同时失效；（redis支持失效时间为毫秒，可以有效的离散对数据提供者的访问）
   * 缓存失效时，采用问题4中的解决方案

###### 3，大量的KEY是非法的数据，没有被缓存；
###### 解决方案A-3-1：
   * 请求是伪造的，为攻击行为，采用对请求参数的严格校验。
###### 方案特点：
   * 参数的产生和校验的方案均需要其他方案配合
   * 无法彻底解决被攻击的现象

###### 解决方案A-3-2：
   * 通过布隆过滤器对参数进行过滤，需要关注布隆过滤器数据的实时性
###### 方案特点：
   * 布隆过滤器可以通过bitmap的方式缓存全量的KEY
   * 可以有效的过滤掉所有非正常KEY的请求
   * 增加了bitmap的维护

###### 4，在特定时期特定产品成为热点，单个key失效时带来的并发请求雪崩
###### 解决方案A-4-1：（redis）
   * 在缓存失效后，在缓存服务中增加互斥锁（set(nx,exprire)），互斥锁过期时间通常为数据提供方的响应时间。
   * 具有互斥锁的进程/线程请求数据并设置缓存，其他进程/线程等待数据设置成功。
###### 方案特点：
   * 在缓存失效后，当前服务为不可用状态，带来坏味道。潜在其他风险。

###### 解决方案A-4-2：（redis）
   * 在get缓存之后，通过 ttl命令探测缓存过期时间，当缓存将要过期时（判断算法为：缓存剩余时间-数据提供方的响应时间<0）获取互斥锁（set(nx,expire)），获取互斥锁成功，产生两个动作，1、通过expire/pexpire命令延长过期时间（数据提供方的响应时间），2、请求数据提供方更新缓存。获取互斥锁失败，则返回正常的缓存数据。
###### 方案特点：
   * 在缓存失效前，便触发更新缓存操作，有效的解决了方案1中的服务等待问题
   * 互斥锁key避免并发，setnx设置过期时间，通常为数据提供方的响应时间。
   * 增加了TTL，EXPIRE/PEXPIRE，互斥锁内容。（ttl+get命令可以通过pipeline技术提升性能）

###### 解决方案A-4-3：（redis/memcache）
   * set双缓存，key为主缓存（过期时间正常），key‘为备份缓存（过期时间+数据提供方的响应时间）
   * get是，先请求key，key失效后，设置互斥锁，设置互斥锁成功，请求数据提供方更新双缓存。设置互斥锁失败，请求key‘缓存，返回。
###### 方案特点：同方案2比较
   * 增加缓存的使用空间
   * 减少了TTL操作

###### 解决方案A-4-N：
   * 解决方案2-3，对缓存过期时间的处理有很多变种可以继续寻找更好的方案，目前推荐采用解决方案A-4-2。
   * 核心特点是：不等待最新的更新数据，返回曾经的缓存数据

### 场景B：（特殊资源缓存，通常是通用数据，热点数据，被动缓存）
   * key为，固定值或者少量固定字符串，value为，任意的字符串。
   * 特点1: 缓存key集中，为热点数据
   * 特点2: 缓存value有时较大 

### 可能带来的问题及解决方案
###### 1，key失效时，带来的高并发穿透；
###### 解决方案B-1-1：
   * 采用A-4-2方案

###### 2，单一key的热点程度高，导致缓存单点CPU成为瓶颈
###### 解决方案B-2-1：
   * 复制key为多个key，分散到多个缓存服务实例，降低单一缓存服务的瓶颈
   * 例：
   ``` 
   有共用key：user_level，value：是一个数组（数据量可大可小），所有的请求均需要访问。
   可以根据需要分散为key：user_level_0,user_level_1,...,user_level_9，
   将数据分散到多个缓存实例中（缓存服务通常是分布式或者cluster组成的集群缓存）
   ```
###### 方案特点：
   * 增加编程复杂度
   * 增加缓存设置为多次设置
   * 增加缓存空间

###### 解决方案B-2-2：
   * 增加二级缓存，缓存服务通常是分布式集群服务，增加在应用服务层的缓存，减少对缓存服务的请求。
###### 方案特点：
   * 增加一层缓存，带来数据一致性问题
   * 对二级缓存数据延迟有一定要求

###### 3，单一key的热点频度高，value较大，导致缓存单点网卡成为瓶颈
###### 解决方案B-3-1：
   * 对缓存value压缩/解压，减少传输流量，其他解决方案同B-2

### 综合解决方案（Z）

### 用缓存带来的问题及解决方案
###### 1，被动缓存后，数据延迟无法满足需求
   * 为了提升性能引入缓存，缓存设置过期时间，过期时间越长系统稳定性，可用性和性能都越高。引入的数据延迟，造成数据延迟问题
###### 解决方案Z-1-1：（通过主被动缓存同时干预，寻找缓存空间和性能的交叉段）
   *通过主动缓存和被动缓存共同参与的方式解决性能和延时的矛盾，将获取数据的方式从拉取改变为通知。
   *被动缓存，设置合理的过期时间（在业务允许下的性能拐点的时长），当缓存中不存在时，读取数据更新到缓存中
   *主动缓存，通过监控数据变更通知（或者数据变更本身）更新缓存，更新时只更新缓存中存在的缓存，不存在的缓存通过被动方式
###### 方案特点：
   * 增加主动缓存方式
   * 改变数据提供方的数据提供方式
   * 增加系统复杂度较大

###### 2，采用多级缓存，造成数据延迟的优化方案
   * 多级缓存的引入，是为了更好的提升性能，避免极端的缓存集群性能，极端带宽带来的问题；同时又增加了一层数据不一致的问题。
###### 解决方案Z-2-1：
   * 设置缓存和缓存更新时间组合来确定本地（一级）缓存是否需要拉取远程（二级）缓存数据，解决带宽问题。
   * 在业务和性能双重允许的情况下，设置缓存和缓存更新时间组合来确定，是否更新
   * 频繁拉取缓存更新时间和本地缓存缓存的更新时间做比较后，确定是延长还是更新本地缓存。
###### 方案特点：
   * 在需要严格数据一致的情况下，需要忽略此方式，太小的缓存时间对系统是负担而不是优化！
   * 在业务和性能两端找平衡点，没有具体业务没有具体的解决方案

###### 3，缓存隔离，对业务的重要程度，紧急程度进行集群隔离
   * 缓存集群权重区分，可用性，性能，监控等指标。通常实施在严格控制成本的团队
###### 解决方案Z-3-1：
   * 对缓存集群的实例分配为多集群，防止非关键业务影响关键业务，提升关键业务的可用性。

## 特别注意：
###### 缓存过期时间的设置思考
   * 1，多级缓存的必要性，并不是每一个key均需要引入多级缓存，只有在可以显著提高性能时，才考虑引入多级缓存，多级缓存务必和每个单个key相关，不做一刀切。
   * 2，当多级缓存无法提供数据一致性时，请通过其他方案实施。不通过联动更新一级缓存和二级缓存的方式
   * 3，一级缓存的过期时间，只考虑的提升性能，在性能的允许下越短越好，充分的测试缓存时间和命中率之间的变现，找到合适的性能点。
   * 4，二级缓存的过期时间，在考虑性能和业务需求中间找平衡点，在业务的允许下保证性能，可用性。

###### TTL命令的风险
   * 在redis的master->slave模式，TTL在master上和slave上表现是否相同，需要测试。不同版本TTL返回的数据不一致。

###### PIPELINE命令的风险
   * 在redis的代理模式和cluster模式下，pipeline命令要进行充分的测试再使用。

###### SETNX命令
   * 用SET(NX,EX），避免设置互斥锁过期时间原子性问题

###### 锁KEY的风险
   * 在设置请求锁的时候，锁的KEY务必和缓存KEY一一对应，避免引入锁共用问题。

## 题外话：
   * 缓存方案通常会和数据接口的限流，降级，熔断，保底数据服务可用性整体考虑，在这方面考虑整体架构时，需要有一个更完整的方案。
   * 1，限流，降级，熔断等的实时接口数据通常采用本地缓存或缓存集群共同提供
   * 2，保底数据，容错数据，通常由缓存系统和应用服务共同提供
